#!/usr/bin/python3
"""Compute object height from the coordinates of its shadow.

    From the coordinates of the base of the object and the tip of the shadow
    together with the calendar date, the object height is computed. This best
    works with thin objects (towers, masts, chimneys).

    The date matters a lot and must thus be known. "Guessing" the date won't
    work.


    Output
    =====
    Height of the building in metres.


    Dependencies
    ============
    * python3
    * python3 module `ephem`


    Assumptions
    ===========
    * The building is vertical.
    * The the shadow tip is at the same elevation as the stack base (flat
      terrain). If, for some reason, you know the elevation difference between
      stack base and shadow tip, you can correct for it by simple
      subtraction/addition to the result.


    Precision
    =========
    The only approximation is the assumtion of a locally flat Earth surface,
    which is very close to exact for all practical purposes
    (building height << Earth's radius).

    Otherwise, the computation is astronomically and mathematically exact.

    Imprecisions thus stem solely from measurement and deviations from the
    above assumptions:
    - elevation difference between stack base and shadow tip
    - building not vertical
    In my tests, I achieved <10% error in flat terrain with little effort.


    Outline of the algorithm
    ========================
    [Caution: `altitude` is an angle here (-> celestial coordinates.)]

    From the shadow coordinates, its length and orientation (angle from North)
    are computed.

    The different positions of the sun in the sky throughout the day in
    question are computed.
    This is done by the `ephem` module. It gives the position as azimuth (angle
    from North) and altitude (angle to the horizon).

    The program searches for the time of the day when the azimuth of the sun is
    opposite to the shadow orientation.

    The altitude of the sun at this instant is then used to retrieve the
    building height by basic trigonometry.


    Testing
    =======
    Script has been tested against buildings with known stack heights.


    Licence
    =======
    * Feel free the use, modify, develop and distribute the script without
      notice to the author.
    * The author doesn't mind being mentioned if you use the script.
    * The author denies all liability for potential software or hardware damage
      or incorrect data. You use this software on your own risk and
      responsibility.


    Author
    ======
    AA : Andreas Anhaeuser
        <andreas.anhaeuser@greenpeace.org>       (currently regularily checked)
        <andreas.anhaeuser.data_analyst@posteo.net> (stable,for the far future)


    History
    =======
    2020-12-22 (AA): Created
"""
# standard modules
import sys
import argparse
import datetime as dt
import math
from math import pi

# PyPI modules
import ephem

# defaults
# =============================
_planet_radius = 6371e3
_date_format = '%Y%m%d'
_time_resolution = 60
# =============================

################################################################
# parser for command-line arguments                            #
################################################################
description = __doc__.split('\n')[0]

FmtClass = argparse.RawDescriptionHelpFormatter
parser = argparse.ArgumentParser(
        description=description, formatter_class=FmtClass,
        )

# this is a bit hack-ish, I don't know how to do that in a clean way:
parser.add_argument('-d', '--doc', action='version', version=__doc__,
        help='show full documentation and exit')

parser.add_argument(
        dest='lon_base_deg', type=float,
        help='(deg) longitude of the object base'
        )
parser.add_argument(
        dest='lat_base_deg', type=float,
        help='(deg) latitude of the object base'
        )
parser.add_argument(
        dest='lon_tip_deg', type=float,
        help='(deg) longitude of the shadow tip'
        )
parser.add_argument(
        dest='lat_tip_deg', type=float,
        help='(deg) latitude of the shadow tip'
        )
parser.add_argument(
        dest='date_stamp', type=str,
        help='(yyyymmdd) date of the scene',
        )
parser.add_argument(
        '-f', dest='date_format', type=str, default=_date_format,
        help='custom format for date stamp (eg. %%Y-%%m-%%d for yyyy-mm-dd)',
        )
parser.add_argument(
        '-r', dest='planet_radius', type=float,
        default=_planet_radius,
        help=('(m) radius of the planet. Default: %i' % _planet_radius),
        )
parser.add_argument(
        '-t', dest='time_resolution', type=int, default=_time_resolution,
        help='(s) temporal resolution. Default: %i' % _time_resolution,
        )

args = parser.parse_args()


# extract input variables
# =================================================
time = dt.datetime.strptime(args.date_stamp, args.date_format)
lat_base_deg =  args.lat_base_deg
lon_base_deg = args.lon_base_deg
lat_tip_deg = args.lat_tip_deg
lon_tip_deg = args.lon_tip_deg

R = args.planet_radius
# =================================================

# deg -> rad
# =================================================
lon_base = math.radians(lon_base_deg)
lat_base = math.radians(lat_base_deg)
lon_tip = math.radians(lon_tip_deg)
lat_tip = math.radians(lat_tip_deg)
# =================================================

# compute shadow length and orientaion
# =================================================
lat_mean = (lat_base + lat_tip) / 2

# local cartesian coordinates (metres)
x = R * (lon_tip - lon_base) * math.cos(lat_mean)
y = R * (lat_tip - lat_base)

# length & orientation
len_shadow = math.sqrt(x**2 + y**2)
azi_shadow = math.atan2(x, y)
# =================================================

# helper functions
# =================================================
def standard_angle(alpha):
    """Wrap an angle to [-pi..pi)."""
    alpha = ((alpha + pi) % (2*pi)) - pi
    assert -pi <= alpha < pi
    return alpha

def absolute_separation(alpha, beta):
    """Return angle separation [0..pi]."""
    sep = (alpha - beta) % (2*pi)
    if sep > pi:
        sep = - (sep - 2*pi)
    assert 0 <= sep <= pi
    return sep
# =================================================


# prepare search loop
# =================================================
# separation between sun rays and shadow orientations
# (the loop minimizes this values)
closest_separation = math.inf

# end of loop
time_inc = dt.timedelta(seconds=args.time_resolution)
time_max = time + dt.timedelta(1)   # one day later
# =================================================

while time < time_max:
    time += time_inc

    # create the observer (i. e. the shadow casting object)
    site = ephem.Observer()
    site.lon = str(lon_base_deg)
    site.lat = str(lat_base_deg)
    site.date = time

    # create the sun
    sun = ephem.Sun(time)
    sun.compute(site)

    # retrieve the sun's position in the sky
    alt_sun = standard_angle(sun.alt)
    azi_sun = standard_angle(sun.az)

    # discard night times
    if alt_sun < 0:
        continue

    # ray of light has azimuth opposite to sun
    azi_ray = azi_sun + pi

    # separation between ray of light and image shadow
    separation = absolute_separation(azi_ray, azi_shadow)

    # check whether ray of light and shadow are aligned
    if separation < closest_separation:
        closest_separation = separation
        closest_altitude = alt_sun

# compute object height
height = len_shadow * math.tan(closest_altitude)
print('%1.1f' % height)
